#TODO:  put only-include-once decoration around header files.
#TODO:  PControl doesn't handle vargs yet.
#TODO:  Function name and return type depend on the return type being a single word.
#TODO:  Handle [][3]
import sys

def write_comment(f, text):
	f.write("/*\n")
	for line in text:
		f.write(" * %s\n" % line)
	f.write(" */\n")

def common_header(f):
	write_comment(f, [
		"This file automatically generated by shim.py.\n",
		"EDIT AT YOUR PERIL."
		])
	
# shim_paramters.h 
class shim_parameters():
	def header(self):
		common_header(self.f)
		# Head matter for shim_parameters.h
		write_comment(self.f, [
			"Contains a union of structs, each one containing ",
			"a copy of the parameters used by the corresponding",
			"MPI function call, as well as a handful of book-",
			"keeping variables.  Using a union keeps the ",
			"instatiated size down, as well as eliminating",
			"namespace clashes caused by different structs using",
			"the same variable names."
		])

		self.f.write("#include <mpi.h>\n")
		self.f.write("#include \"shim_structs.h\"\n")
		self.f.write("union shim_parameters {\n")
		self.f.write("#include \"shim_union.h\"\n")
		self.f.write("};\n")
	def body(self, line, return_type, function_name, parameters):
		pass
	def footer(self):
		pass

#shim_functions.c 
#       WARNING.  THIS IS NEARLY IDENTICAL TO gmpi.c.  
#                 ANY CHANGES MADE HERE SHOULD PROBABLY BE MADE
#                 THERE AS WELL.
class shim_functions():
	def header(self):
		common_header(self.f)
		write_comment(self.f, [
			"MPI_* calls are weakly declared.  This allows us to ",
			"link in our own function calls using the same name.",
			"Instead of a namespace class, the weakly declared ",
			"functions aren't used.  We access the normal MPI_*",
			"functionality using the corresponding PMPI_* call.",
			"Our intercept code (pre/post) is called before and",
			"after the PMPI_* call."
		])
		self.f.write("#include \"shim_selection.h\"\n")
		self.f.write("#include \"shim_enumeration.h\"\n")
		self.f.write("#include \"shim.h\"\n")
	def body(self, line, return_type, function_name, parameters):
		# Function comment and #ifdef.
		self.f.write("\n")
		self.f.write("//%s\n" % (function_name))
		self.f.write("#ifdef USE_%s\n" % (function_name.upper()))

		# Function definition.
		self.f.write("%s\n" % (return_type))
		self.f.write("%s (%s){\n" % (function_name, ",".join(parameters)))

		# Local variables.
		self.f.write("\tunion shim_parameters shim;\n")
		self.f.write("\tint shim_id;\n")

		#copy function call parameters & such to the union.struct.
		self.f.write("\tshim_id = shim.%s_p.shim_id = G%s;\n" 
			% (function_name, function_name.upper()))
		for p in parameters:
			p=p.strip()
			if(p != "void" and p !="..."):
				p=p.replace("*",'')
				self.f.write("\tshim.%s_p.%s = %s;\n" 
					% (function_name, 
						p.split(" ")[-1], p.split(" ")[-1]))

		#pre-intercept call.
		self.f.write("\tshim_pre( shim_id, &shim );\n")

		#PMPI call
		self.f.write("\tshim.%s_p.rc = P%s(" % ( function_name, function_name)) 
		count=1
		for p in parameters:
			p=p.strip()
			if(p != "void" and p !="..."):
				p=p.replace("*",'')
				if(count == 1):
					self.f.write("%s" % (p.split(" ")[-1]))
				else:
					self.f.write(", %s" % (p.split(" ")[-1]))
				count+=1
		self.f.write(");\n")

		#post-intercept call.
		self.f.write("\tshim_post( shim_id, &shim );\n")
		self.f.write("\treturn shim.%s_p.rc;\n" % (function_name))
		self.f.write("}\n")
		self.f.write("#endif //USE_%s\n" % (function_name.upper()))

	def footer(self):
		pass

#shim_selection.h
class shim_selection():
	def header(self):
		common_header(self.f)
		write_comment(self.f, [
			"The intercept code is surrounded by #ifdefs.",
			"Define the functions that we want to trap here.",
			"In this case, comment out the #defines that you",
			"don't want to see.  ",
			])
	def body(self, line, return_type, function_name, parameters):
		# Write out selection.
		self.f.write("#define USE_%s\n" % (function_name.upper()))
	def footer(self):
		pass

#shim_enumeration.h
class shim_enumeration():
	def header(self):
		# Head matter for shim_enumeration.h
		common_header(self.f)
		write_comment(self.f, [
			"In order to keep track of which call we've intercepted,",
			"the intercepting code adds a function-specifc integer",
			"tag to the parameter struct.  This file generates those",
			"tags."
		])
		self.f.write("enum{\n")
	def body(self, line, return_type, function_name, parameters):
		# Write out the enumeration.
		self.f.write("\tG%s,\n" % (function_name.upper()))
	def footer(self):
		# Foot matter for shim_enumeration.h
		self.f.write("\tSHIM_NUM_FUNCTIONS\n")
		self.f.write("};\n")

#shim_structs.h
class shim_structs():
	def header(self):
		common_header(self.f)
		write_comment(self.f, [
			"Parameter structs needs to be defined before",
			"they can be included in the union.  We define",
			"the structs here."
		])
		self.f.write("\tstruct MPI_Dummy_p{\n")
		self.f.write("\t\tint   shim_id;\n")
		self.f.write("\t\tchar *srcfile;\n")
		self.f.write("\t\tint   srcline;\n")
		self.f.write("\t};\n\n" )
	def body(self, line, return_type, function_name, parameters):
		# Write out the structs.
		self.f.write("\tstruct %s_p{\n" % (function_name))
		self.f.write("\t\tint   shim_id;\n")
		self.f.write("\t\tchar *srcfile;\n")
		self.f.write("\t\tint   srcline;\n")
		self.f.write("\t\t%s rc;\n" % (return_type))
		for p in parameters:
			p=p.strip()
			p=p.replace("const ", '')	# stupid Pcontrol.
			if(p != "void" and p !="..."):
				self.f.write("\t\t%s;\n" % (p.strip()))
		self.f.write("\t};\n\n" )

	def footer(self):
		pass

#shim_union.h
class shim_union():
	def header(self):
		common_header(self.f)
		write_comment(self.f, [
			"These struct declarations populate the union."
		])
		self.f.write("\tstruct MPI_Dummy_p MPI_Dummy_p;\n")
	def body(self, line, return_type, function_name, parameters):
		# Write out the union.
		self.f.write("\tstruct %s_p %s_p;\n" % (function_name, function_name))
	def footer(self):
		pass

#shim_str.h
class shim_str():
	def header(self):
		common_header(self.f)
		write_comment(self.f, [
			"Converts from the function's integer tag and ",
			"the string of the function's name.",
		])
	def body(self, line, return_type, function_name, parameters):
		# Write out the str.
		self.f.write("case G%s:  str=\"%s\"; break;\n" % (function_name.upper(), function_name))
	def footer(self):
		pass

#gmpi_redefine_definition
class gmpi_redefine_definitions():
	def header(self):
		common_header(self.f)
		write_comment(self.f, [
			"#defines used to redefine the MPI_* functions",
			"so that they pass in __FILE__ and __LINE__",
			"parameters.",
			"",
			"Insert this BEFORE the #include <mpi.h>",
			"statement."
		])
	def body(self, line, return_type, function_name, parameters):
		# Write out gmpi_defines.h
		p=["a","b","c","d","e","f","g","h","i","j","k","l","m"]
		self.f.write("#undef %s\n" % (function_name) )
		self.f.write("#define %s(" % (function_name) )
		self.f.write(  "%s"  % ( ",".join(p[0:len(parameters)]) )  )
		self.f.write(") %s(" % ( function_name.replace("MPI_","GMPI_")) )
		if( "void" not in parameters ):
			self.f.write(  "char *srcfile, int srcline," )
			self.f.write(  "%s"  % ( ",".join(p[0:len(parameters)]) )  )
		else:
			self.f.write(  "char *srcfile, int srcline" )
		self.f.write(")\n")
	def footer(self):
		pass

#gmpi_redefine_use
class gmpi_redefine_use():
	def header(self):
		common_header(self.f)
		write_comment(self.f, [
			"#defines used to redefine the MPI_* functions",
			"so that they pass in __FILE__ and __LINE__",
			"parameters.",
			"",
			"Insert this AFTER the #include <mpi.h>",
			"statement."
		])
	def body(self, line, return_type, function_name, parameters):
		# Write out gmpi_defines.h
		p=["a","b","c","d","e","f","g","h","i","j","k","l","m"]
		self.f.write("#undef %s\n" % (function_name) )
		self.f.write("#define %s(" % (function_name) )
		self.f.write(  "%s"  % ( ",".join(p[0:len(parameters)]) )  )
		self.f.write(") %s(" % ( function_name.replace("MPI_","GMPI_")) )
		if( "void" not in parameters ):
			self.f.write(  "__FILE__,__LINE__," )
			self.f.write(  "%s"  % ( ",".join(p[0:len(parameters)]) )  )
		else:
			self.f.write(  "__FILE__,__LINE__" )
		self.f.write(")\n")
	def footer(self):
		pass

#gmpi.h
class gmpi_h():
	def header(self):
		common_header(self.f)
	def body(self, line, return_type, function_name, parameters):
		# Write out gmpi.h
		if( "void" in parameters ):
			self.f.write(  "%s %s( char *srcfile, int srcline );\n" % ( return_type, function_name.replace("MPI_", "GMPI_") )  )
		else:
			self.f.write(  "%s %s( char *srcfile, int srcline, %s );\n" % ( return_type, function_name.replace("MPI_", "GMPI_"), ", ".join(parameters) )  )
	def footer(self):
		pass

#gmpi.c 
#       WARNING.  THIS IS NEARLY IDENTICAL TO shim_functions.c.  
#                 ANY CHANGES MADE HERE SHOULD PROBABLY BE MADE
#                 THERE AS WELL.
class gmpi_c():
	def header(self):
		common_header(self.f)
		# Head matter for shim_functions.c and gmpi.c
		self.f.write("#include \"shim_selection.h\"\n")
		self.f.write("#include \"shim_enumeration.h\"\n")
		self.f.write("#include \"shim.h\"\n")
		self.f.write("#include \"gmpi.h\"\n")
	def body(self, line, return_type, function_name, parameters):
		self.f.write("\n")
		self.f.write("//G%s\n" % (function_name))
		self.f.write("#ifdef USE_%s\n" % (function_name.upper()))
		self.f.write("%s\n" % (return_type))
		if( "void" in parameters ):
			self.f.write("%s ( char *srcfile, int srcline ){\n" % (function_name.replace("MPI_", "GMPI_")))
		else:
			self.f.write("%s ( char *srcfile, int srcline, %s ){\n" % (function_name.replace("MPI_", "GMPI_"), ", ".join(parameters)))
		self.f.write("\tunion shim_parameters shim;\n")
		self.f.write("\tint shim_id;\n")

		#write parameters & such to the function.
		self.f.write("\tshim_id = %s;\n" % (function_name.upper()))
		for p in parameters:
			p=p.strip()
			if(p != "void" and p !="..."):
				p=p.replace("*",'')
				self.f.write("\tshim.%s_p.%s = %s;\n" % (function_name, p.split(" ")[-1], p.split(" ")[-1]))
		self.f.write("\tshim.%s_p.srcfile = srcfile;\n" % (function_name) )
		self.f.write("\tshim.%s_p.srcline = srcline;\n" % (function_name) )
		self.f.write("\tshim.%s_p.shim_id = shim_id;\n" % (function_name) )
		#pre
		self.f.write("\tshim_pre( shim_id, &shim );\n")

		#PMPI call
		self.f.write("\tshim.%s_p.rc = P%s(" % ( function_name, function_name)) 
		count=1
		for p in parameters:
			p=p.strip()
			if(p != "void" and p !="..."):
				p=p.replace("*",'')
				if(count == 1):
					self.f.write("%s" % (p.split(" ")[-1]))
				else:
					self.f.write(", %s" % (p.split(" ")[-1]))
				count+=1
		self.f.write(");\n")

		#post
		self.f.write("\tshim_post( shim_id, &shim );\n")
		self.f.write("\treturn shim.%s_p.rc;\n" % (function_name))
		self.f.write("}\n")
		self.f.write("#endif //USE_%s\n" % (function_name.upper()))
		self.f.write("\n")
	def footer(self):
		pass

###########################################################################################
###########################################################################################
###########################################################################################



# Input file declarations w/o semicolons.  The conversion from mpi.h to this 
# format is handled in the makefile.
#
# int MPI_Add_error_class(int *errorclass)
# or
# int MPI_Alloc_mem(MPI_Aint size, MPI_Info info, void *baseptr)

lines=sys.stdin.readlines()

fd=[
	file("shim_parameters.h",  		"w"),
	file("shim_functions.c",   		"w"),
	file("shim_selection.h",   		"w"),
	file("shim_enumeration.h", 		"w"),
	file("shim_structs.h",     		"w"),
	file("shim_union.h",       		"w"),
	file("shim_str.h",         		"w")

	#file("gmpi_redefine_definitions.h",	"w"),
	#file("gmpi_redefine_use.h",		"w"),
	#file("gmpi.h",				"w"),
	#file("gmpi.c",				"w")
]

c=[
	shim_parameters(),
	shim_functions(),
	shim_selection(),
	shim_enumeration(),
	shim_structs(),
	shim_union(),
	shim_str()
	
	#gmpi_redefine_definitions(),
	#gmpi_redefine_use(),
	#gmpi_h(),
	#gmpi_c()
]

# Give each class instantiaon its file descriptor.
# Might be better in the constructor.
for i in xrange(len(c)):
	c[i].f = fd[i]

# First write out all of the header material.
for i in c:
	i.header()

# Parse the mpi.h file.  The preprocessing takes place in the Makefile.
for line in lines:

	# We're going to do this slow and stupid.
	line = line.strip()
	return_type   = line.split(" ")[0].strip()		
	function_name = line.split(" ")[1].split("(")[0]
	parameters    = line[0:-1].split("(")[1].split(",")

	# Haven't figured out how to handle this case yet.  Skip it for now.
	#
	#1011 OMPI_DECLSPEC  int MPI_Group_range_excl(MPI_Group group, int n, int ranges[][3],
	#1012                                         MPI_Group *newgroup);
	#1013 OMPI_DECLSPEC  int MPI_Group_range_incl(MPI_Group group, int n, int ranges[][3],
	#1014                                         MPI_Group *newgroup);
	if (function_name in ["MPI_Group_range_excl", "MPI_Group_range_incl"]):
		continue
	
	# For each line, write the body.
	for i in c:
		i.body(line, return_type, function_name, parameters)
		

# Write the footer.
for i in c:
	i.footer()
	
# Clean up.
for f in fd:
	f.close()
	 
